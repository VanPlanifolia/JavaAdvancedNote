## 

##### 7.java中的双亲委派机制

在java中为了保证类加载的安全性引入了双亲委派机制，就比如当类加载器受到类加载的请求，那么它会向上委托父类加载器，一直往上知道委托到启动类加载器，如果启动类加载器能够找到这个类则直接执行，如果找不到它会去通知它的下一层子类加载器如果能够找则直接执行如果找不到则继续往下委派直到最后应用程序加载器也找不到则抛出class not found异常。

8.jvm的内存空间

jdk8之前，jvm的内存空间大概分为 两块：

线程共享的：堆内存保存对象实例的（年轻代，老年代）方法区/永久代（保存类的具体信息，也就是class对象保存的一些信息）

线程独享的：本地方法栈（用于保存一个个本地方法的栈帧，里面包括被调用的本地方法的信息包括局部变量返回地址等等等），虚拟机栈（用于保存一个个实例方法的栈帧），程序计数器（用于记录程序执行的位置，比如循环调用其他方法等等程序运行的流程都是由它来操控的）

到了jdk8，jvm取消了永久代，将这个概念替换成了原空间，原空间直接存储在物理内存中不再保存在jvm虚拟机内存中了，在元空间中用于保存一些需要永久保存的对象实例信息，并且在原空间中有一块内存区域来作为方法区来存储被加载的类信息，而且在这个方法区中有一小块作为运行时常量池。

9.GC算法

* 复制算法

我们上面已经说了堆内存中保存对象实例可以分为 年轻代，老年代，其中年轻代又可以分为 伊甸园区，幸存区0，幸存区1.这两个幸存区是用来保存伊甸园区中在轻gc下存活下来的对象，复制算法要求的是这两个区必须要有一个区是空的那么每次我们往幸存区中复制gc后存活的对象时它都会把另一个幸存区的对象复制过来，并且清空那个幸存区来接受下次gc幸存下来的对象，然后两个幸存区彼此交换位置，这个算法的好处就是能够保留完整的内存空间来存储对象，不会产生碎片化内存空间。

* 标记清除算法

标记清除算法则是会先遍历一遍

* 标记清除压缩算法
* 引用计数法
